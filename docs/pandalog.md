
Pandalog
========

Introduction
------------

Panda analyses run on whole system replays and the clear temptation is to just print out what you learn as you learn it. So panda plugins often begin life peppered with print statements. There is nothing wrong with print statements. But, as a plugin matures, it is usual for the consumers of those print statements to yearn for more compact, more parseable output. Pandalog provides this in the form of protocol buffer messages, streamed to a file through zlib's file access functions.


Design
------

Pandalog is designed to be

1. Fast to read and write
2. Small log size
3. Easy to add to a plugin
4. Easy to write code that reads the log
5. Useable from any C or C++ panda plugin

Goals 1 and 2 are (arguably) provided by Google's protocol buffers. 
Protocol buffers optimize for small message size. 
Marshalling / unmarshalling is reasonably speedy. 
Better than JSON. 
We would have liked to use something like flatbuffers (also from Google), which is optimized more for read/write speed (we want FAST plugins, dammit). 
But this would have violated goal 5, as there is no way to auto-generate code for C with flatbuffers, as yet. 
A big design goal here (3) was for the logging spec to be distributed throughout the plugins. 
That is, if new plugin foo wants to write something to the pandalog, it should only have to specify what new fields it wants to add to the pandalog and add the actual logging statements. 

Adding Panda Logging to a Plugin
--------------------------------

The `asidstory` plugin is a good example. 
Two small additions are all that are required to add pandalogging.

First, a new file was added to the plugin directory

    % cd qemu/panda_plugins/asidstory/
    % cat asidstory.proto
    optional uint64 asid = 3; 
    optional string process_name = 4;
    optional uint32 process_id = 5;
    % 

This file contains a snippet from a protocol buffer schema.
It indicates that this plugin will be adding three new optional fields to the pandalog, one for the `asid` (address space id), 
one for the `process_name`, and another for the `process_id`.
Note that these fields are given *tag numbers*.
This is important in so far as no two protobuf fields can have the same number (we don't know why).
That is a global constraint you need to be aware of across all plugins.
If `asidstory` uses slot 3, then plugin `foo` better not try to use it as well.
Don't worry; if you screw this up, you'll get an error at build time.

Second, the actual logging message was inserted into `asidstory.cpp`

    extern "C" {
    ...
    #include "pandalog.h"
    ...
    }
    ...
    int asidstory_before_block_exec(CPUState *env, TranslationBlock *tb) {
    ...
           if (pandalog) {
            if (last_name == 0
                || (p->asid != last_asid)
                || (p->pid != last_pid) 
                || (0 != strcmp(p->name, last_name))) {        
                Panda__LogEntry ple = PANDA__LOG_ENTRY__INIT;
                ple.has_asid = 1;
                ple.asid = p->asid;
                ple.has_process_id = 1;
                ple.process_id = p->pid;
                ple.process_name = p->name;
                pandalog_write_entry(&ple);           
                last_asid = p->asid;
                last_pid = p->pid;
                free(last_name);
                last_name = strdup(p->name);
            }
        }
    ...

The logging message was inserted into the function `asidstory_before_block_exec`, and the logic is complicated
by the fact that we are keeping track of the last asid, process name, and process id.
When any of them change, we write a pandalog message.
All of that is incidental.

Note that we have available to us a global `pandalog`, which we can use to determine if panda logging is turned on.  

To add the logging message, you have to create the `ple`, initializing it as so:

      Panda__LogEntry ple = PANDA__LOG_ENTRY__INIT;

That `ple` is just a C struct, defined in autogenerated code.
Look in `panda/qemu/panda/pandalog.pb-c.h` for the typedef of `Panda__LogEntry`.
Once you have a `ple`, you just populate it with the fields you want logged.
Note that, if fields are optional, there is always a `has_fieldname` bool you need to
set to indicate its presence. 
Well, not quite. 
If the field is a pointer (an array or a string), a null pointer stands in for `has_fieldname=0`.

Here is the part of the code above in which we populate the struct for logging

                ple.has_asid = 1;
                ple.asid = p->asid;
                ple.has_process_id = 1;
                ple.process_id = p->pid;
                ple.process_name = p->name;

Now all that is left is to write the entry to the pandalog.

                pandalog_write_entry(&ple);


Building
--------

In order to use pandalogging, you will have to re-run `build.sh`.

This build script has been modified to additionally run a new script `panda/pp.sh`, which
peeks into all of the plugin directories, and looks for `.proto` snippets, concatenating them all together into
a single file: `panda/qemu/panda/pandalog.proto`.
This script then runs `protoc-c` on that specification to generate two files: `panda/qemu/panda/pandalog.pb-c.[ch]`.

Feel free to peek at any of those three auto-generated files.
In particular, you will probably want to consult the header since it defines the logging struct
`Panda__LogEntry`, as indicated above.


Pandalogging During Replay
--------------------------

Panda logging is enabled at runtime with a new command-line arg.

  --pandalog filename

Any specified plugins that write to the pandalog will log to that file, which is written via `zlib` file access functions for compression.


Looking at the Logfile
----------------------

There is a small program in `panda/qemu/panda/pandalog_reader.cpp`.
Compilation directions are at the head of that source file.

You can read a pandalog using this little program and also see how easy it is to unmarshall the pandalog.
Here's how to use it and some of its output.

    % ./pandalog_reader /tmp/pandlog | head
    instr=16356  pc=0xc12c3586 :  asid=2 pid=171 process=[jbd2/sda1-8] 
    instr=78182  pc=0xc12c3586 :  asid=2 pid=4 process=[kworker/0:0]   
    instr=80130  pc=0xc12c3586 :  asid=2 pid=171 process=[jbd2/sda1-8] 
    instr=142967  pc=0xc12c3586 :  asid=2 pid=4 process=[kworker/0:0]  
    instr=209715  pc=0xc12c3586 :  asid=7984000 pid=2511 process=[sshd]
    instr=253940  pc=0xc12c3586 :  asid=2 pid=4 process=[kworker/0:0]  
    instr=256674  pc=0xc12c3586 :  asid=5349000 pid=2512 process=[bash]
    instr=258267  pc=0xc12c3586 :  asid=7984000 pid=2511 process=[sshd]
    instr=262487  pc=0xc12c3586 :  asid=2 pid=4 process=[kworker/0:0]  
    instr=268164  pc=0xc12c3586 :  asid=5349000 pid=2512 process=[bash]


Note that there are two required fields always added to every pandalog entry: instruction count and program counter.
The rest of thes log messages come from the asidstory logging.  




External References
===================

You may want to search google for "Protocol Buffers" to learn more about it.

