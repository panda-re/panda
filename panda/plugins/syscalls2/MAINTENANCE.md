# syscalls2 maintenance

**Note:** This document is work in progress. There is also some documentation in docs/syscalls2.md.

In this document we highlight how support for new operating systems can be added to `syscalls2`. Overall, this is a three step process:

A. Extract the system call prototypes for the new OS. The prototypes in general consist of the system call *number* and function *signature*.

B. Generate headers and source files from the prototypes, so that `syscalls2` will be able to intercept the system calls for the target OS.

C. Modify the hand-written syscalls2 code to include the profile for the new target.

## Extracting system call prototypes

The files used to generate the prototype files are in the `scripts` folder:

- `make_all_prototypes.sh` - calls `prototype_parser.py` for each target
- `prototype_parser.py` - uses the `prototype_parser_config.py` to create the desired prototype file
- `prototype_parser_config.py` - configuration information needed to generate each prototype

Also, a configuration in `prototype_parser_config.py` may refer to additional signature information specified in files in the `generated-in` folder.

### Linux
For extracting the linux system call prototypes, you will need a copy of the linux source.  This is achieved by adding a configuration to the script `prototype_parser_config.py` that points to the source tree.  The configuration needs to specify where within the source tree the mapping of system call number to name can be found (see the `map_function_number` section), and what files to parse for the system call signatures (see the `map_function_signature` section).

It is recommended to use the Ubuntu sources, as it includes a number of additional system calls. This has the side-effect that when `syscalls2` analyzes kernels provided by other vendors, the results for non-standard system calls may be off.

Ubuntu sources have the peculiarity that some of the headers required by the extraction script have to be generated. Following are the rough steps to prepare an Ubuntu source tree.

```sh
git clone git://kernel.ubuntu.com/ubuntu/ubuntu-bionic.git
cd ubuntu-bionic
git checkout Ubuntu-4.15.0-97.98
cat ./debian.master/config/{config.common.ubuntu,i386/config.common.i386,i386/config.flavour.generic} > .config
make
```

Compilation may fail after this but it doesn't matter, as long as the required `unistd` header files were generated.

Then, modify either `make_all_prototypes.sh` or `prototype_parser_config.py` to point to your source tree.

Execute `make_all_prototypes.sh` to create a mytarget_prototypes.txt file in the `generated-in` folder.  If only a few prototypes need to be (re)generated, you can also call `prototype_parser.py` individually for each one. 

### Windows
TBD

## Generating `syscalls2` support files

The files used to generate the C/C++ headers and sources are in the `scripts`, `generated-in` and `generated-tbl` folders:

- `scripts/make_all_generated.sh` - calls `syscall_parser.py` for the desired targets
- `generated-in/context_target.json` - lists system calls that do not return for certain targets; specified by `make_all_generated.sh` as input to `syscall_parser.py`.
- `generated-tpl/` - contains template files used by `syscall_parser.py`
- `generated-in/` - contains the prototypes.txt files generated by `make_all_prototypes.sh` and used as input to `make_all_generated.sh`

Some of the files created by `make_all_generated.sh` contain information on more than one target.  Thus it is necessary to have all input prepared, and to run the script with all targets specified.  The output will be written to the `generated` folder.

### Linux
Modify `make_all_generated.sh` to add your new target to the `syscall_parser.py` arguments.

If your new target has any system calls that do not return, add a section for your target naming them in the `context_target.json` file.

In `syscall_parser.py`, it may be necessary to add a new architecture and/or OS, and to tweak the type lists and/or their processing to properly convert the types encountered in your new target's prototype file.

### Windows
TBD

## Modifying syscalls2 hand-written code

Modify `syscalls2.h` to add function prototypes for the generated enter and return callbacks.  See the comment above the list in the file for directions on how to easily generate this list from the files created by `make_all_generated.sh`.

Modify `syscalls2.cpp` to add a new profile for your new target, and add code to select it under the appropriate conditions when the plugin is initialized.

Review `syscalls2_info.c` and tweak if necessary to ensure the correct syscalls information file will be loaded for the new target.

And now, finally, rebuild the `syscalls2` plugin.
