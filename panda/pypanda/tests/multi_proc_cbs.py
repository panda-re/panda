#!/usr/bin/env python3
from sys import argv
from os import path
import capstone
from panda import Panda, ffi, blocking

# Single arg of arch, defaults to i386
arch = "i386" if len(argv) <= 1 else argv[1]
panda = Panda(generic=arch)
md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)

# Take a recording of toy running in the guest if necessary
if not path.isfile("toy-rr-snp"):
    @blocking
    def run_toy():
        panda.record_cmd("toy/toy toy/testsmall.bin", "toy", recording_name="toy")
        panda.stop_run()

    print("Generating toy replay")
    panda.queue_async(run_toy)
    panda.run()

hit_toy = False
hit_ata = False
hit_always = False

@panda.cb_before_block_exec(procname="ata_id")
def ata_before_block(env, tb):
    global hit_ata
    if not hit_ata:
        hit_ata = True
    return 0

@panda.cb_before_block_exec(procname="toy")
def toy_before_block(env, tb):
    global hit_toy
    if not hit_toy:
        hit_toy = True
    return 0

@panda.cb_before_block_exec
def always_before_block(env, tb):
    global hit_always
    if not hit_always:
        hit_always = True
    return 0

panda.run_replay("toy") # Generated by hand with scissors from toy

print("TOY:", hit_toy)
print("ATA:", hit_ata)
print("ALL:", hit_always)
assert (hit_toy and hit_ata and hit_always),  "Callbacks didn't all run"
print("Success! All three callbacks ran as anticipated")
